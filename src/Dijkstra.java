import java.util.ArrayList;

public class Dijkstra {
    /**
     * Implements Dijkstra's shortest path algorithm for a graph represented as an adjacency list.
     * Calculates the shortest distance from the source to all other vertices and reconstructs the path.
     *
     * @param adjacencyList The graph represented as an adjacency list, where each index corresponds to a vertex
     *                      and contains a list of edges originating from that vertex.
     * @param source        The source node index from which the shortest paths are calculated.
     * @param destination   The target node index to which the shortest path is determined.
     * @return A {@code DijkstraResult} object containing:
     *         <ul>
     *             <li>{@code distanceArray} - The shortest distance from the source to each vertex.</li>
     *             <li>{@code path} - The reconstructed path from source to destination.</li>
     *         </ul>
     */
    public static DijkstraResult dijkstra(ArrayList<ArrayList<Edge>> adjacencyList, int source, int destination) {
        int vertexCount = adjacencyList.size(); // Total number of vertices in the graph

        // Array to store the shortest distance from the source to each vertex
        double[] distanceArray = new double[vertexCount];
        for (int i = 0; i < distanceArray.length; i++) {
            distanceArray[i] = Double.MAX_VALUE; // Initialize distances as "infinite"
        }
        distanceArray[source] = 0; // Distance to the source itself is zero

        // Parent array to reconstruct the shortest path for each vertex
        int[] parent = new int[vertexCount];
        for (int i = 0; i < parent.length; i++) {
            parent[i] = -1; // Initialize parent array with -1 (no parent)
        }

        // MinHeap for efficiently selecting the vertex with the smallest known distance
        MyMinHeap heap = new MyMinHeap(vertexCount);
        heap.insert(new MyMinHeap.Vertex(source, 0)); // Start with the source vertex

        // Main loop: Process vertices until no reachable vertices remain
        while (!heap.isEmpty()) {
            // Extract the vertex with the smallest distance from the heap
            MyMinHeap.Vertex current = heap.extractMin();
            int vertexU = current.id; // The vertex being processed

            // Update the distances for all adjacent vertices of vertexU
            for (Edge edge : adjacencyList.get(vertexU)) {
                int vertexV = edge.to; // Adjacent vertex
                double weight = edge.weight; // Weight of the edge

                // Relaxation step: Check if a shorter path is found
                if (distanceArray[vertexU] + weight < distanceArray[vertexV]) {
                    parent[vertexV] = vertexU; // Update the parent to reconstruct the path
                    distanceArray[vertexV] = distanceArray[vertexU] + weight; // Update the shortest distance

                    // Insert or update the vertex in the heap with the new distance
                    heap.insert(new MyMinHeap.Vertex(vertexV, distanceArray[vertexV]));
                }
            }
        }

        // Check if a path to the destination exists
        ArrayList<Integer> path = new ArrayList<>();
        if (distanceArray[destination] != Double.MAX_VALUE) {
            path = reconstructPath(destination, parent); // Reconstruct the path
        } else {
            System.out.println("No path could be found."); // No valid path
        }

        return new DijkstraResult(distanceArray, path); // Return the distances and path
    }

    /**
     * Utility method to reconstruct the path from the source to the destination.
     *
     * @param destination The destination node index.
     * @param parent      The parent array generated by Dijkstra's algorithm, where each index stores the
     *                    preceding vertex in the shortest path.
     * @return An {@code ArrayList<Integer>} of node indices representing the path from the source to the destination.
     */
    private static ArrayList<Integer> reconstructPath(int destination, int[] parent) {
        ArrayList<Integer> path = new ArrayList<>();
        // Traverse the parent array from destination to source
        for (int at = destination; at != -1; at = parent[at]) {
            path.add(0, at); // Insert each vertex at the beginning to reverse the order
        }
        return path;
    }

    /**
     * Represents an edge in the graph's adjacency list.
     * An edge connects a vertex to another vertex with a specified weight.
     */
    public static class Edge {
        int to; // The destination vertex of the edge
        double weight; // The weight of the edge

        /**
         * Constructs an {@code Edge} object.
         *
         * @param to     The destination vertex index.
         * @param weight The weight of the edge.
         */
        public Edge(int to, double weight) {
            this.to = to;
            this.weight = weight;
        }
    }
}
